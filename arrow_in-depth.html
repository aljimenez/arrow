<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Arrow : FE Test framework designed to promote TDD" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Arrow In-Depth</title>
</head>
<body>

<script type="text/javascript" src="javascripts/header.js"> </script>
<script type="text/javascript" src="javascripts/menu.js"> </script>

<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
<section id="main_content" class="inner">

<h3><a name="Arrow In-Depth" class="anchor" href="#arrow-In-depth"><span class="octicon octicon-link"></span></a>Arrow In-Depth</h3>
<p>Arrow provides you with a variety of tools to help you organize, execute and configure your tests.
    </p>

<h3><a name="Test Suite Organization" class="anchor" href="#test-suite-organization"><span class="octicon octicon-link"></span></a>Test Suite Organization</h3>
<p>Test descriptor files allow you to organize your tests into test suites, while also allowing you to control when and which tests execute at a given phase of your development cycle.
</p>
<p>
Consider the following scenario:
 </p>
<p>
            You have just finished creating a suite of tests that validate the application we discussed in the <a href= "arrow_tutorial.html">Arrow Tutorial</a>. <br>
        </p>

        <p>
            At this point you have the following test files:
            <ul>
                <li>Functional Tests</li>
                <li>Integration Tests</li>
            </ul>
        </p>

        <p>
            For this sample, we'll pretend unit tests are being addressed elsewhere.
        </p>

        <p>
            If you recall, to execute the two test files above against our mock and HTTP endpoint, we'd type something like this:
        </p>


            <pre><code>
./node_modules/.bin/arrow func_test/test/test-func.js  --page=testMock.html --lib=func_test/test/test-lib.js
./node_modules/.bin/arrow func_test/test/test-func.js  --page=http://www.doctor46.com/tabview.html --lib=func_test/test/test-lib.js
./node_modules/.bin/arrow func_test/test/test-int.js  --page=http://www.doctor46.com/tabview.html --lib=func_test/test/test-lib.js
            </code></pre>

        <p>
            Let's pretend we wanted to easily decide which test files executed and which didn't. Test <a href="arrow_in-depth.html#test-descriptors">descriptors</a> allow you to do this easily and in one location.
        </p>

 <h3><a name="Test Descriptors" class="anchor" href="#test-descriptors"><span class="octicon octicon-link"></span></a>Test Descriptors</h3>
        <p>
            Test descriptors provide a way to describe, organize and factorize your tests. During test development, you'll probably execute each test from the Arrow command line. However, once you have created tests to validate your module, you need a way to organize and factorize the tests.
        </p>
        <p>
            Lets look at this test <a href="https://github.com/yahoo/arrow/tree/master/docs/arrow_tutorial/func_test/test/test_descriptor.json">descriptor</a>.
        </p>

            <pre><code>

    [
        {
            "settings": [ "master" ],

            "name" : "tabview",

            "commonlib" : "./test-lib.js",

            "config" :{
                "baseUrl" : "http://www.doctor46.com"
            },

            "dataprovider" : {

                "dom" : {
                    "params" : {
                        "test" : "test-func.js",
                        "page" : "testMock.html"
                    },
                    "group" : "unit"
                },

               "dom_int" : {
                    "params" : {
                        "test" : "test-func.js",
                        "page" : "$$config.baseUrl$$/tabview.html"
                      },
                    "group" : "smoke"
                },

                "int" : {
                    "params" : {
                        "test" : "test-int.js",
                        "page" : "$$config.baseUrl$$/tabview.html"
                    },
                    "group" : "smoke"
                }

            }

        },

        {
            "settings": [ "environment:development" ]
        }

    ]

            </code></pre>

<h4><a name="Suite Settings" class="anchor" href="#suite-settings"><span class="octicon octicon-link"></span></a>Suite Settings</h4>

        <p>
            These settings are accessible by all tests in the suite - name and commonlib
        </p>

            <pre>
 "name" : "tabview",
 "commonlib" : "./test-lib.js",
            </pre>

            <ul>
                <li>
                    <em>name:</em> Allows you to give your descriptor a name. In Arrow you can run multiple test descriptors in a single execution. Giving it a name allows you to separate the results.
                </li>
                <li>
                    <em>commonlib:</em> Behaves like a suite-level <em>--lib</em> parameter. Rather than calling each necessary dependency or lib in the tests, you can do that here. <em>commonlib</em> is not limited to only one dependency. If you have more than one dependency, you can specify them with commas.
                </li>
            </ul>


 <h4><a name="Suite Configuration" class="anchor" href="#suite-configuration"><span class="octicon octicon-link"></span></a>Suite Configuration</h4>

        <p>
            The settings here, allow you to override default config settings and apply to the entire suite.
        </p>

            <pre>
"config" :{
"defaultAppHost" : "http://www.doctor46.com"
 },
            </pre>
        <p>
            In this example we have a key called <em>defaultAppHost</em>. The value assigned to this key can be picked up using the <em>$$</em> annotation, for example  <em>$$config.defaultAppHost$$</em>.
        </p>

        <p>
            This is one way we can parametrize our tests and make them easier to execute/share.
        </p>


<h4><a name="Individual Test Settings" class="anchor" href="#individual-test-settings"><span class="octicon octicon-link"></span></a>Individual Test Settings</h4>

<p>
    This section uses the Suite Settings and the Suite Configuration to create instances of your tests.

    <pre>
"dom_int" : {
"params" : {
   "test" : "test-func.js",
   "page" :"testMock.html"
},
"group" : "unit"
},
    </pre>

</p>


        <ul>
            <li>
                The first object is the name of the test. In this case, the test name is <em>dom_int</em>.
            </li>
            <li>
                The next object, <em>params</em>, includes the necessary parameters for the test.
            </li>
            <li>
                <em>test</em>: Tells Arrow which file to execute
            </li>
            <li>
                <em>page</em>: Tells Arrow against which page to execute. The <em>page</em> value can be a local mock page served by arrow_server, or an HTTP endpoint
            </li>
            <li>
                <em>group</em>: Allows you to <b>group</b> your tests for execution. Each test <em>file</em> contains a set of tests or assertions. At the time of creation, tests do not have a context (at least not implied). A <em>group</em> gives those test <em>files</em> context, enabling you to execute only a given set of tests during a given execution.
            </li>

        </ul>

 <h3><a name="Executing using a Test Descriptor" class="anchor" href="#executing-using-a-test-descriptor"><span class="octicon octicon-link"></span></a>Executing using a Test Descriptor</h3>

 <p>
 To execute <b>All</b> tests in a given test descriptor file, simply type (remember in this example, the name of our file is <em>test-descriptor.json</em>):
 </p>
<pre>
 ./node_modules/.bin/arrow func_test/test/test-descriptor.json
</pre>
 <p>
 However, if you wanted to <b>only</b> execute tests <em>grouped</em> as <em>func</em>, you would type:
</p>
<pre>
 ./node_modules/.bin/arrow func_test/test/test-descriptor.json --group=func
</pre>
 <p>
 Similarly, you can choose to <b>only</b> execute a given test, based on its name. You can do that by typing:
</p>
<pre>
 ./node_modules/.bin/arrow func_test/test/test-descriptor.json --testName=dom
</pre>

<h3><a name="Test Descriptor Best Practices" class="anchor" href="#test-descriptor-best-practices"><span class="octicon octicon-link"></span></a>Test Descriptor Best Practices</h3>
<h4><a name="One Test Descriptor Per Module" class="anchor" href="#One-test-descriptor-per-module"><span class="octicon octicon-link"></span></a>One Test Descriptor Per Module</h4>
<p>
 One test descriptor per module is recommended. You do not need a <em>parent</em> test descriptor file to include multiple modules. There are different tools which do this for you. Given a root directory, Arrow traverses the child directories and picks up the required test descriptor files.
</p>
<p>
 For example, suppose you have the following directory structure, and within each module/test folder you have tests and a test descriptor file.
</p>
<pre>

 project1
 |____ module1
 |        |_____src
 |        |_____test
 |            |_____test-descriptor1.json
 |
 |____ module2
 |        |_____src
 |        |_____test
 |            |_____test-descriptor2.json
 |
 |____ module3
 |        |_____src
 |        |_____test
 |            |_____test-descriptor3.json
 |
 |____ module4
 |_____src
 |_____test
 |_____test-descriptor4.json

 </pre>

 <p>

 To execute <em>All</em> test descriptor files <em>within</em> each module, simply navigate to the project root (in this case <em>project1</em>) and type:
 </p>

 <pre>
 ./node_modules/.bin/arrow "func_test/**/*-descriptor.json"
 </pre>
 <p>
 Arrow will traverse through all sub-folders, pick up the test descriptors which match <em>"**/*-descriptor.json"</em> glob, and execute them sequentially.
 </p>

 <h4><a name="Parametrize Test Descriptors" class="anchor" href="#parametrize-test-descriptors"><span class="octicon octicon-link"></span></a>Parametrize Test Descriptors</h4>
<p>
 There are tests which require parametrization. Specially in <em>Integration</em> tests (int), it is important to have a way to parametrize the host name of your AUT.
</p>
<p>
 Test descriptors allow you to parametrize like this:
</p>

<pre>

     "dom_int" : {
     "params" : {
         "test" : "test-func.js",
         "page" :"$$config.defaultAppHost$$/tabview.html"
     },
     "group" : "smoke"
     },

     "int" : {
     "params" : {
         "test" : "test-int.js",
         "page" : "$$config.defaultAppHost$$/tabview.html"
     },
     "group" : "smoke"
     }

 </pre>
 <p>
 Where <em>"defaultAppHost" : "http://doctor46.com"</em>
</p>

 <h3><a name="Test Descriptor Parametrization and Test Environments" class="anchor" href="#test-descriptor-parametrization-and-test-environments"><span class="octicon octicon-link"></span></a>Test Descriptor Parametrization and Test Environments</h3>
<p>
 So far our parametrization examples have only applied to our current file. If we want to run our tests across different environments (with different hostnames), we'd have to create multiple test-descriptor.json files to do this. However, we can use a `dimension` file to give our parameters additional <em>dimension</em> or context.
</p>
<p>
 At the bottom of our test descriptor file there was this line:
</p>
<pre>

 {
 "settings": [ "environment:development" ]
 }
</pre>
 <p>
 We can make use of the line above, and a <em>dimension</em> file to dynamically change configuration values given a context.

 With this <em>dimension</em> file we can set different contexts in our test descriptor:
</p>
<pre>

 [
     {
         "dimensions": [
             {
             "environment":
                 {
                     "development": {
                        "test": null
                     },
                     "integration": {
                        "test": null
                     },
                     "stage": {
                        "test": null
                     },
                     "production": {
                         "test": null
                     }
                 }
             }
         ]
     }
 ]

</pre>
 <p>
 Now we can update our test descriptor like this</p>

<pre>

 {
     "settings": [ "environment:development" ],

     "config" :{
        "defaultAppHost" : "http://development.com"
     }
 },

 {
     "settings": [ "environment:integration" ],

     "config" :{
        "defaultAppHost" : "http://integration.com"
     }
 },

 {
     "settings": [ "environment:stage" ],

     "config" :{
        "defaultAppHost" : "http://stage.com"
     }
 },

 {
     "settings": [ "environment:production" ],

     "config" :{
        "defaultAppHost" : "http://production.com"
     }
 }
 </pre>
 <p>
 During execution, we can set the context like this:
 </p>

 <pre>
 ./node_modules/.bin/arrow test-descriptor.json --context=environment:development --dimensions=./dimensions.json
</pre>
Or
 <pre>
 ./node_modules/.bin/arrow test-descriptor.json --context=environment:stage --dimensions=./dimensions.json
 </pre>
 <p>
 In each case, Arrow will take the <em>context</em> and <em>dimensions</em> file and use those to map the correct <em>config</em> value for the current execution
</p>

<h3><a name="replaceParamJSON" class="anchor" href="#replaceParamJSON"><span class="octicon octicon-link"></span></a>replaceParamJSON</h3>
<p>
 This parameter is optional and can be used when user wants to configure descriptors to replace certain values on the fly.
</p>
<p>
 It could either be passed as .json object or as a string in json format.
</p>
 <h4><a name="replace.json sample" class="anchor" href="#replace.json-sample"><span class="octicon octicon-link"></span></a>replace.json sample</h4>

<pre>
 {
    "property" : "finance"
 }
</pre>
 <p>
The descriptor will appear as follows for the given replace.json
</p>
 <h4><a name="descriptor.json sample" class="anchor" href="#descriptor.json-sample"><span class="octicon octicon-link"></span></a>descriptor.json sample</h4>
<pre>
 [
     {
         "settings":[ "master" ],
         "name":"descriptor",
         "config":{
            "baseUrl": "http://${property}$.yahoo.com"
         },
         "dataprovider":{
         "Test sample":{
         "params": {
                "test": "test.js"
                "page":"$$config.baseUrl$$"
                }
            }
        }
     }
 ]
 </pre>
 Now, if user runs the descriptor

 <pre>
 ./node_modules/.bin/arrow ./descriptor.json --replaceParamJSON=./replace.json --browser=firefox
 </pre>
 or
 <pre>
 ./node_modules/.bin/arrow ./descriptor.json --replaceParamJSON='{"property":"finance"}' --browser=firefox
 </pre>
 <p>
 The value of 'baseUrl' which is 'http://${property}$.yahoo.com' will become 'http://finance.yahoo.com'
 </p>

 <h3><a name="defaultParamJSON" class="anchor" href="#defaultParamJSON"><span class="octicon octicon-link"></span></a>defaultParamJSON</h3>
 <p>
 This parameter is optional and can be used when user wants to use default values for the parameters which are not specified in replaceParamJSON.
 If user has specified replaceParamJSON and the value is not found in replaceParamJSON , it looks for the value in defaultParamJSON.
 </p>
 <p>
 It could either be passed as .json object or as a string in json format.
 </p>
 <h4><a name=" default.json sample" class="anchor" href="#default.json-sample"><span class="octicon octicon-link"></span></a>default.json sample</h4>
<pre>

{
     "property" : "finance",
     "site" : "yahoo"
}

</pre>
 <h4><a name="replace.json_2 sample" class="anchor" href="#replace.json_2-sample"><span class="octicon octicon-link"></span></a>replace.json sample</h4>
<pre>
 {
    "property" : "news"
 }
</pre>
 <p>
The descriptor will appear as follows for the given replace.json
</p>
 <h4><a name="descriptor2.json sample" class="anchor" href="#descriptor2.json-sample"><span class="octicon octicon-link"></span></a>descriptor.json sample</h4>
<pre>

 [
     {
     "settings":[ "master" ],
     "name":"descriptor",
     "config":{
        "baseUrl": "http://${property}$.${site}.com"
     },
     "dataprovider":{
     "Test sample":{
     "params": {
                "test": "test.js"
                "page":"$$config.baseUrl$$"
                }
            }
        }
     }
 ]
</pre>
 <p>
 Now, if user runs the descriptor
 </p>
 <pre>

 ./node_modules/.bin/arrow --replaceParamJSON=./replace.json --defaultParamJSON=./default.json --browser=firefox
 or
 ./node_modules/.bin/arrow --replaceParamJSON='{"property":"news"}' --defaultParamJSON='{"property":"finance","site":"yahoo"}' --browser=firefox

 </pre>
 <p>
 The value of 'baseUrl' which is 'http://${property}$.${site}.com' will become 'http://news.yahoo.com'.<br/>

 If user only passes defaultParamJSON,

 </p>

 <pre>
 ./node_modules/.bin/arrow ./descriptor.json --defaultParamJSON=./default.json --browser=firefox
 or
 ./node_modules/.bin/arrow ./descriptor.json --defaultParamJSON='{"property":"finance","site":"yahoo"}' --browser=firefox

 </pre>
 <p>
 The value of 'baseUrl' which is 'http://${property}$.${site}.com' will become 'http://finance.yahoo.com'
 </p>

 <h3><a name="Configuration" class="anchor" href="#configuration"><span class="octicon octicon-link"></span></a>Configuration</h3>
<p>
 There are various ways to configure Arrow. Normally, Arrow's configuration file will be installed here
</p>

 <h4><a name="Configuration Location" class="anchor" href="#configuration-location"><span class="octicon octicon-link"></span></a>Configuration Location</h4>
 <p>
 The default configuration file is located under - /node_modules/arrow/config/config.js
 The standard arrow config file looks like this
 </p>
<pre>

// User default config
config.seleniumHost = ""; //example: config.seleniumHost = "http://gridhost:port/wd/hub";
config.phantomHost = "http://localhost:4445/wd/hub";
config.context = "";
config.defaultAppHost = "";
config.logLevel = "INFO";
config.browser = "firefox";
config.parallel = false;
config.baseUrl = "";
// Framework config
config.arrowModuleRoot = global.appRoot + "/";
config.dimensions = config.arrowModuleRoot + "config/dimensions.json";
config.defaultTestHost = config.arrowModuleRoot + "lib/client/testHost.html";
config.defaultAppSeed = "http://yui.yahooapis.com/3.8.0/build/yui/yui-min.js";
config.autolib = config.arrowModuleRoot + "lib/common";

//for yui sandbox
config.useYUISandbox = false;  // when this is set to true,arrow will use an absolute YUI instead of the YUI on (or injected on) the page.
config.sandboxYUIVersion = '3.8.0'; // please try make this the same with yui npm package version
config.yuiSandboxRuntime = config.arrowModuleRoot + "lib/client/yui-test-runtime.js";  // default runtime js if download yui modules failed

// for test engine
config.engine="yui";   // yui, mocha, jasmine or qunit,default to "yui"
config.engineConfig="";  // config object or fs path to the engine config if supported by engine(like mocha)
config.testSeed = config.arrowModuleRoot + "lib/client/yuitest-seed.js";
config.testRunner = config.arrowModuleRoot + "lib/client/yuitest-runner.js";

// config for share lib
config.shareLibPath = ["./common"];     // Arrow will scan all given path for share lib. Example: [config.arrowModuleRoot + "../"]
                                  // You can modify this to add multiple share lib path.
config.scanShareLibPrefix = [];    // Arrow will only scan share lib with given prefix "martini_" if configured as ["martini_"]
                                  // Or it will scan all folders for share lib under given path if it is empty : []
                                  // You can modify this to add multiple prefix.
config.scanShareLibRecursive = true;     // Only scan top level folders for the given prefix and given scan path if false,
                                         // Otherwise it will scan recursively with the given path.
config.enableShareLibYUILoader = false;    // Default false , inject all necessary share lib source code into test cases .
                                           // If true, generate and inject YUI group/modules info and let YUI loader to load modules.
                                           // the reason we need this is because in yahoo network lot of time
                                           // lab manager windows VM's don't have access to any non-80 port of hudson slaves.
                                           // In those scenarios, YUI config would be a blocker and YUI loader wont work.


config.descriptorName = "test_descriptor.json";
config.minPort = 10000;
config.maxPort = 11000;
config.coverage = false;
config.coverageExclude = "";
config.exitCode = false;
config.retryCount = 0;
config.keepIstanbulCoverageJson = false;
config.color = true;
config.report = true;

config.testTimeOut = 30000; // if test does not get over in these many ms, Arrow fails the test.

config.ignoreSslErrorsPhantomJs = true;


 config.context = "";
 config.defaultAppHost = "";
 config.logLevel = "INFO";
 config.browser = "firefox";
 config.parallel = false;
 config.baseUrl = "";
 // Framework config
 config.arrowModuleRoot = global.appRoot + "/";
 config.dimensions = config.arrowModuleRoot + "config/dimensions.json";
 config.defaultTestHost = config.arrowModuleRoot + "lib/client/testHost.html";
 config.defaultAppSeed = "http://yui.yahooapis.com/3.6.0/build/yui/yui-min.js";
 config.testSeed = config.arrowModuleRoot + "lib/client/yuitest-seed.js";
 config.testRunner = config.arrowModuleRoot + "lib/client/yuitest-runner.js";
 config.autolib = config.arrowModuleRoot + "lib/common";
 config.descriptorName = "test_descriptor.json";

</pre>
 <p>
 As you can see there are two types of configuration sections:
 </p>
 <ul>
     <li>User Config: These are configuration parameters which directly affect how your test or test suite will execute</li>
     <li>Framework Config: These are configuration parameters which indirectly affect how your test or test suite will execute</li>
 </ul>

<h4><a name="Overriding Configuration Values" class="anchor" href="#overriding-configuration-values"><span class="octicon octicon-link"></span></a> Overriding Configuration Values</h4>
<p>
Obviously, you can update the config file to <em>override</em> its settings. However, you can also <em>override</em> individual config parameters on a per-execution basis. Every config parameter can be <em>overridden</em> during execution like this:
</p>
<pre>
./node_modules/.bin/arrow &lt;some test or test descriptor&gt; --config=value
or
./node_modules/.bin/arrow &lt;some test or test descriptor&gt; --seleniumHost=http://some.url.com:1234/wd/hub
or
./node_modules/.bin/arrow &lt;some test or test descriptor&gt; --logLevel=debug --baseUrl=http://baseurl.com --browser=chrome
</pre>
 <p>
 You can basically override any config parameter in the command line.
</p>
<p>
 You can also <strong>completely</strong> override all configuration values by placing a config.js file at the root of your execution. Arrow always looks at the current directory for config.js file. If it finds one, it will use <strong>that</strong> file over the default configuration.
</p>

<h3><a name="Complex Test Scenarios" class="anchor" href="#complex-test-scenarios"><span class="octicon octicon-link"></span></a>Complex Test Scenarios</h3>
<p>
 There are situations where the default arrow controller will not allow you to create the type of test scenario you require. If you recall, the default arrow controller assumes the page you load is the page under test. To solve this you can use a different arrow controller called <strong>locator</strong>. The <strong>locator</strong> controller allows you to navigate to the page under test by allowing you to perform actions such as clicking and typing.
</p>
<p>
 The controller samples can be found <a href="https://github.com/yahoo/arrow/tree/master/docs/arrow_tutorial/controllers/test">here </a>.
</p>

 <h4><a name="The Locator Controller" class="anchor" href="#the-locator-controller"><span class="octicon octicon-link"></span></a>The Locator Controller</h4>
<p>
 To use the <em>locator</em> controller you need to use a test descriptor with an additional node, <b>scenario</b>.
</p>
 <p>
 Suppose you wanted to test finance.yahoo.com's ticker quotes engine. To do that, you would build a scenario like this:
 </p>
 <ul>
     <ol>1. Open <a href="">http://finance.yahoo.com</a></ol>
     <ol>2. Use the <em>locator</em> controller and look for the <em>ticker</em> input textbox and enter <em>yhoo</em></ol>
     <ol>3. Use the <em>locator</em> controller and <em>click</em> on the submit button</ol>
     <ol>4. Wait for the page to load <b>and</b> now test for quotes</ol>
 </ul>
 <p>
 Based on the scenario above, our test descriptor file would look like this:
 </p>
 <pre>

 "dataprovider" : {

 "Test YHOO Ticker" : {
     "group" : "func",
     "params" :{
     "scenario": [
                     {
                        "page": "$$config.baseUrl$$"
                     },
                     {
                         "controller": "locator",
                         "params": {
                             "value": ".yucs-search-input",
                             "text": "yhoo"
                         }
                     },
                     {
                         "controller": "locator",
                         "params": {
                             "value": "#yucs-sprop_button",
                             "click": true
                         }
                     },
                     {
                         "test": "test-quote.js",
                         "quote": "Yahoo! Inc. (YHOO)"
                     }
                  ]
                }
     }
 }
</pre>
 <p>
 Our first step is to open the page (Arrow will use the <em>default</em> controller when none is specified). Secondly we look for an input field with a locator value of <em>#txtQuotes</em> and we enter <em>yhoo</em>. Then we use the <em>locator</em> controller to <em>click</em> on <em>#btnQuotes</em>. Finally we inject our test JS file and using <em>this.params</em> we pass the value in <em>quote</em> to the test file.
 </p>
 <p>
 Our test continues being a simple YUI test which takes input from the test descriptor in order to do its validation.
 </p>
<pre>

 YUI({ useBrowserConsole: true }).use("node", "test", function(Y) {
     var suite = new Y.Test.Suite("Quote Page test of the test");
     suite.add(new Y.Test.Case({
         "test quote": function() {

             //In order to parametrize this, instead of having a static quote, we call it from the config
             var quote = this.testParams["quote"];
             Y.Assert.areEqual(quote, Y.one(".yfi_rt_quote_summary").one("h2").get('text'));
         }
     }));

     Y.Test.Runner.add(suite);
 });
</pre>

 To execute we simply type the following:

<pre>
 ./node_modules/.bin/arrow test-descriptor.json --driver=selenium
</pre>
 <p>
 As you can see, the <em>locator</em> controller is quite powerful. It can take the following <em>params</em>
 </p>
 <ul>
     <li><b>value</b>: locator value</li>
     <li><b>click</b>: true or false</li>
     <li><b>text</b>: value ot enter</li>
     <li><b>using</b>: by default, Arrow will assume you want to use <em>css</em> locators for <em>value</em>. However you can use any <b>By</b> strategy supported by WebDriver: className, id, linkText, name, text, xpath, etc.</li>
 </ul>
 For example, you could have the following in your test descriptor

<pre>

 {
     "controller": "locator",
     "params": {
             "using": "xpath",
             "value": "//*[@id="yucs-sprop_button"]",
             "click": true
         }
 }

</pre>

 <h3><a name="The Custom Controller" class="anchor" href="#the-custom-controller"><span class="octicon octicon-link"></span></a>The Custom Controller</h3>
<p>
 User can write custom controller if the requirement is not getting fulfilled by the locator controller. It does support all the latest webdriver methods.
</p><p>
 For example, given below is the finance-controller.js which does similar to what we just explained in the locator controller sample.
</p>
 <p>
 Based on the scenario above, our test descriptor file would look like this:
 </p>
<pre>

 var util = require("util");
 var log4js = require("yahoo-arrow").log4js;
 var Controller = require("yahoo-arrow").controller;

 function FinanceCustomController(testConfig,args,driver) {
     Controller.call(this, testConfig,args,driver);

     this.logger = log4js.getLogger("FinanceCustomController");
 }

 util.inherits(FinanceCustomController, Controller);

 FinanceCustomController.prototype.execute = function(callback) {
     var self = this;

     if(this.driver.webdriver){

         //Get the various parameters needed from the Test Descriptor file
         var txtLocator =  this.testParams.txtLocator;
         var typeText =  this.testParams.typeText;
         var btnLocator =  this.testParams.btnLocator;
         var page = this.testParams.page;

         //Get a handle of the WebDriver Object
         var webdriver = this.driver.webdriver;

         //Open the page you want to test
         webdriver.get(page);
         webdriver.waitForElementPresent(webdriver.By.css(txtLocator));
         //Navigate the page as necessary
         webdriver.findElement(webdriver.By.css(txtLocator)).sendKeys(typeText);
         webdriver.findElement(webdriver.By.css(btnLocator)).click();
         webdriver.waitForElementPresent(webdriver.By.css(".title")).then(function() {
             self.driver.executeTest(self.testConfig, self.testParams, function(error, report) {
                callback(error);
             });

         });
     }else{
         this.logger.fatal("Custom Controllers are currently only supported on Selenium Browsers");
         callback("Custom Controllers are currently only supported on Selenium Browsers");
     }
 }

 module.exports = FinanceCustomController;
</pre>

 The descriptor for the custom controller will be little different since we need the params to be passed from it and it looks like,

<pre>

 [
     {
         "settings":[ "master" ],

         "name":"controllers",

         "config":{
            "baseUrl":"http://finance.yahoo.com"
         },

         "dataprovider":{

             "Test YHOO Ticker using Finance Controller":{
                 "group":"func",
                 "controller":"finance-controller.js",
                 "params":{
                     "page":"$$config.baseUrl$$",
                     "txtLocator":".yucs-search-input",
                     "typeText":"yhoo",
                     "btnLocator":"#yucs-sprop_button",
                     "test":"test-quote.js",
                     "quote":"Yahoo! Inc. (YHOO)"
                 }
             }
         }
     },
     {
        "settings":[ "environment:development" ]
     }
 ]
</pre>
 Custom controller best practice
 <ol>
     <li>Make sure to include "var log4js = require("yahoo-arrow").log4js;" and "var Controller = require("yahoo-arrow").controller" to access yahoo-arrow.</li>
     <li>Make sure to include "waitForElementPresent(webdriver.By.css(".title"))" before calling the callback() to return to the test or else sometime, "ARROW is not defined" error will appear since the test try to execute before even loading the page completely.</li>
 
 </ol>

<h4><a name="Sharing test parameters among custom controllers and tests in a scenario node" class="anchor" href="#share-test-param"><span class="octicon octicon-link"></span></a>Sharing test parameters among custom controllers and tests in a scenario node</h4>
<p>
    In a complex test scenario, we may need multiple controllers or tests in a scenario node. Arrow provides a way to share variables among the controllers or tests, via this.testParams.shared.
    Custom controller or test can set a Json object to this.testParams.shared, then it will pass to downstream controllers and tests.
</p>
<p>
    The sample of sharing testParams from a test to another test can be found <a href="https://github.com/yahoo/arrow/tree/master/tests/functional/data/arrow_test/share_test_params/test_params_share-simple.json">here </a>.
</p>
<p>
    The sample of sharing testParams for a custom controller to downstream custom controller and test can be found <a href="https://github.com/yahoo/arrow/tree/master/tests/functional/data/arrow_test/share_test_params/search-descriptor-test-params.json">here</a>.
</p>



 <h3><a name="Test Engine" class="anchor" href="#test-engine"><span class="octicon octicon-link"></span></a>Test Engine</h3>

<p>
 Internally, test engine is an adaptor to support different styles test cases, like YUI, QUnit, BDD, TDD.
</p>
 <p>
 By default, Arrow is using YUI style testing. It can be changed by specifying '--engine', with below supported:
 </p>
 <ul>
     <li>yui (default)</li>
     <li>mocha</li>
     <li>jasmine</li>
     <li>qunit</li>
 </ul>

 <h4><a name="Using --engine in arrow cmd" class="anchor" href="#using-engine-in-arrow-cmd"><span class="octicon octicon-link"></span></a>Using --engine in arrow cmd</h4>

 Suppose you have a test case written in the popular BDD way,like:

 <pre>
 describe('Array', function(){
     describe('#push()', function(){
         it('should return the length', function(){
             var arr = [],
             assert = function(expr, msg) {
                 if (!expr) throw new Error(msg || 'failed');
             }
             assert(1 == arr.push('foo'));
             assert(2 == arr.push('bar'));
             assert(3 == arr.push('baz'));
         })
     })
 })
</pre>
 Then you can use test engine mocha to run it ,for example:

<pre>
 ./node_modules/.bin/arrow mocha-bdd.js --engine=mocha
</pre>

 And if you want to run it in client side ,just simply run :

<pre>
 ./node_modules/.bin/arrow mocha-bdd.js --engine=moch --browser=chrome

 ./node_modules/.bin/arrow mocha-bdd.js --engine=mocha --browser=phantomjs --page=http://serach.yahoo.com
</pre>

 Suppose you have a test case written in tdd way and you want to use chai as assertion :

<pre>

 suite('Array', function(){
     suite('#indexOf()', function(){
         test('should return -1 when not present', function(){
             var chai;
             if(typeof window  == "undefined" && typeof chai  == "undefined"){
                chai = require('chai');
             }
             else{
                chai = window.chai;
             }
             chai.assert(-1 == [1,2,3].indexOf(4));
         });
     });
 });
</pre>
 then you can still want mocha run it but using different "interface" in mocha like this:

<pre>
./node_modules/.bin/arrow mocha-tdd.js --engine=mocha  --engineConfig=./config.json
</pre>
 or in browser side:
<pre>
 ./node_modules/.bin/arrow mocha-tdd.js --engine=mocha  --engineConfig=./config.json  --browser=chrome
</pre>
 you can define any configuration recognized by mocha like "ui","reporter" etc. in config.json:

<pre>
 {"ui":"tdd","require":"chai"}
</pre>

 It will be passed to test engine and take effect in test execution.

<strong>
 NOTE: This example shows that we just need to add chai to "require" field in engine config to support chai as mocha's offical assertion set.
 </strong>
Also npm package or http links are supported in engine config.
 <pre>
 {"ui":"tdd","require":["chai","should","http://chaijs.com/chai.js"]}
 </pre>




 <h4><a name="Using engine in arrow's test descriptor" class="anchor" href="#using-engine-in-arrow-test-descriptor"><span class="octicon octicon-link"></span></a>Using engine in arrow's test descriptor</h4>

 If you have multiple style test cases and want to test it in one test descriptor ,you just need to specify which engine to use in descriptor:

<pre>

 {
     "settings":[ "master" ],
     "name":"hybrid engine server side",
     "dataprovider":{
         "mocha":{
             "params":{
                 "test":"mocha-bdd.js",
                 "engine":"mocha"
             },
             "group":"unit"
         },
         "mocha-tdd":{
             "params":{
                 "test":"mocha-tdd.js",
                 "engine":"mocha",
                 "engineConfig":"./mocha-config.json"
             },
            "group":"unit"
         },
         "jasmine":{
             "params":{
                 "test":"jasmine-bdd-test.js",
                 "engine":"jasmine"
             },
             "group":"unit"
         },
         "qunit":{
             "params":{
                "test":"qunit-test.js",
                "engine":"qunit"
             },
             "group":"unit"
         },
         "yui":{
             "params":{
                 "test":"yui-test-unit.js",
                 "lib":"./yui-lib.js"
             },
             "group":"unit"
         }
     }
 }
</pre>
 <p>
 Here qunit-test.js and jasmine-bdd-test.js are test cases can be run within qunit and jasmine. By default arrow will use yui to run tests,so in test "yui" ,
 we didn't need to specify the engine for test yui-test-unit.js.
 </p>
 Test engine can also work in scenario node:

<pre>

 {
     "settings": [ "master" ],
     "name": "YahooLogin",
     "config": {
        "baseUrl": "http://login.yahoo.com"
     },
     "commonlib" : "./mocha-lib.js",
     "dataprovider" : {
         "Use Locator to Login" : {
             "group" : "func",
             "browser":"chrome",
             "params" :{
                 "scenario": [
                 {
                     "page": "$$config.baseUrl$$"
                 },
                 {
                     "controller": "locator",
                     "params": {
                            "value": "#username",
                            "text": "arrowtestuser1"
                         }
                 },
                 {
                     "controller": "locator",
                     "params": {
                            "value": "#passwd",
                            "text": "123456"
                         }
                 },
                 {
                     "controller": "locator",
                     "params": {
                            "value": "#submit",
                            "click": true
                         }
                 },
                 {
                     "page": "http://search.yahoo.com/"
                 },
                 {
                     "test": "mocha-test.js",
                     "engine":"mocha"
                 }
                ]
             }
         }
     }
 }
</pre>
 In this test, arrow will use the locator controller to find elements in login page and after that it will go to search page to run a mocha-style test.
 Users can add any kind of test cases only if the related test engine is suppported and specified with "engine" field.

 <h3><a name="YUI abstraction (YUI sandboxing)" class="anchor" href="#yui-abstraction"><span class="octicon octicon-link"></span></a>YUI abstraction (YUI sandboxing)</h3>
<p>
 Most of yahoo pages are built on YUI, if you are writing YUI test case testing against YUI pages, then YUI sandbox has great benefit with below scenarios:
</p>
<ul>
    <li>The testing page builds on a lower YUI version (YUI@2.x or 3.x) .</li>
    <li>The page has some restriction for YUI loader to fetch external modules (like mojito apps).</li>
    <li>Simply you don't want to let test case affect the page or the features.</li>
</ul>

 Then you can use YUI sandbox to test your code.

 <h4><a name="How to use" class="anchor" href="#how-to-use"><span class="octicon octicon-link"></span></a>How to use</h4>

 You can simply modify arrowRoot/config/config.js to set sandbox to true, or pass from command line:

<pre>
 config.useYUISandbox = true  or   --useYUISandbox=true  </pre>


 Also you can figure whatever YUI version you want by config.sandboxYUIVersion or --sandboxYUIVersion, by default it will use the same version as YUI in arrow/node_modules, and it is what we recommended.

 <h4><a name="Not to use" class="anchor" href="#not-to-use"><span class="octicon octicon-link"></span></a>Not to use</h4>

 However under some situations , you should NOT use YUI sandbox:
 <ul>
     <li>Your test cases requires YUI modules only served on the test page, for example:</li>
 </ul>
 <pre>
 YUI.add('example-tests',function(Y){...},'1.0.0', { requires: [ 'node' ] });,
 </pre>

 And 'example-module' is only served in test-page.html, then the page level YUI should be used instead of YUI in a sandbox.

 <h4><a name="Sandbox detail(Advanced)" class="anchor" href="#sandbox-detail"><span class="octicon octicon-link"></span></a>Sandbox detail(Advanced)</h4>
<p>
 Suppose we have a YUI test case and also have some test libs written as YUI.add(…), then we will wrap all these in IEFF(Immediately Executed Factory Function).
</p>
<pre>

 (function () {
     var YUI;
     ... //  1. all yui min/base goes here...
     YUI.add(...)  // 2. all yui core modules goes here
     YUI.add/use(...) // 3. custom's yui libs and yui tests goes here
     YUITest/TestRunner... // 4. yui test runner start.
 })();
 </pre>
 <p>
 So that this sandbox(IEFF) contains all:  yui seed, yui core modules(auto resolved from test case/test libs), test libs, test cases and test engine.
 It is an absolute YUI instance and doesn't depend (or mess with) the YUI on test page.
 </p>


 <h3><a name="Re-Using Browser Sessions" class="anchor" href="#re-using-browser-sessions"><span class="octicon octicon-link"></span></a>Re-Using Browser Sessions</h3>
<p>
 As you develop your tests, you may find it necessary to <em>test</em> them against a real browser, such as those supported by Selenium. However, one of the disadvantages of this approach is that normally, for each test file, a new browser session is started and stopped. This is time consuming and counter-productive during development.
 </p>
 <p>
 Arrow supports the concept of <b>Session Reuse</b>.
</p>

 <h3><a name="Using Session-Reuse" class="anchor" href="#using-session-reuse"><span class="octicon octicon-link"></span></a>Using Session-Reuse</h3>

 Webdriver has a concept of sessions. Once a Selenium/WebDriver server instance is running, you can tell Selenium to <em>reuse</em> a given session. This is a very powerful and helpful idea because:
 <ul>
     <li>It expedites execution since a new browser window does not need to be instantiated. This greatly cuts down on execution time and puts <em>real</em> browser test execution time in-par with PhantomJS</li>
     <li>As a developer, you can tell Selenium to <em>use</em> your preferred <em>profile</em> for the session. This means that if you have special plugins (such firebug, or developer tools, etc) installed, you can make use of them during test execution.</li>
 </ul>
 However, one should keep in mind that this approach means your test will have a non-sterile environment as session and cookie information will be <strong>reused</strong>

 To use <em>Session-Reuse</em> do the following:

 <ol>
     <li>From within the machine running Selenium server go to: http://localhost:4444/wd/hub/static/resource/hub.html</li>
     <li>Click on <em>create session</em> and choose the browser you want</li>
     <li>A new Browser will start (that is your session) and set itself to a blank page</li>
     <li>To tell Arrow to <b>Reuse</b> that session type:</li>

 </ol>
<pre>
 ./node_modules/.bin/arrow &ltsome test or test descriptor&gt --reuseSession=true
</pre>
<p>
 Arrow will contact the Selenium Server in the config and will ask it if there are any <em>reusable</em> sessions. If so, it will direct all tests to them.
</p>
 Note: Arrow will direct all tests to <b>ALL OPEN</b> sessions. If you want to further expedite your test execution time, you can start sessions for different browser and Arrow will execute your tests in parallel against all of them.

 <h3><a name="Using Session-Reuse With Specific Profiles" class="anchor" href="#using-session-reuse-profiles"><span class="octicon octicon-link"></span></a>Using Session-Reuse With Specific Profiles</h3>

 If you want to <em>reuse</em> your default profile, or a specific profile you use for developing simply type this when you start Selenium server.

<pre>

 java -Dwebdriver.firefox.profile=default -jar ./path/to/selenium/sever.jar </pre>

 Or

<pre>

 java -Dwebdriver.firefox.profile=profile_name -jar ./path/to/selenium/sever.jar  </pre>

 Once Selenium is started, the same steps for <em>reusing</em> sessions apply.

 <h3><a name="Running tests using single browser" class="anchor" href="#running-tests-using-single-browser"><span class="octicon octicon-link"></span></a>Running tests using single browser</h3>

 Assuming you have selenium server already running on localhost port 4444.

<pre>
./node_modules/.bin/arrow ./int/test-descriptor.json --browser=firefox
./node_modules/.bin/arrow ./int/test-descriptor.json --browser=chrome
</pre>

 Assuming you have phantomjs already running on localhost port 4445.

 <pre>
 ./node_modules/.bin/arrow ./int/test-descriptor.json --browser=phantomjs
 </pre>

 <h3><a name="Running tests using multiple browsers" class="anchor" href="#running-tests-using-multiple-browsers"><span class="octicon octicon-link"></span></a>Running tests using multiple browsers</h3>

 <pre>
 ./node_modules/.bin/arrow ./int/test-descriptor.json --browser=firefox,chrome
 ./node_modules/.bin/arrow ./int/test-descriptor.json --browser=chrome,phantomjs
 </pre>

 <h3><a name="Running tests on remote host" class="anchor" href="#running-tests-on-remote-host"><span class="octicon octicon-link"></span></a>Running tests on remote host</h3>

 All above tests can also run on remote host by specifying "--seleniumHost" and "--phantomHost".

<pre>
 ./node_modules/.bin/arrow ./int/test-descriptor.json --seleniumHost='http://x.x.x.x:4444/wd/hub' --browser=chrome

 ./node_modules/.bin/arrow ./int/test-descriptor.json --phantomHost='http://x.x.x.x:4445/wd/hub' --browser=phantomjs

 ./node_modules/.bin/arrow ./int/test-descriptor.json --phantomHost='http://x.x.x.x:4445/wd/hub' --seleniumHost='http://x.x.x.x:4444/wd/hub' --browser=phantomjs,chrome
</pre>

<h3><a name="Parallelism" class="anchor" href="#parallelism"><span class="octicon octicon-link"></span></a>Parallelism</h3>

Arrow supports parallel execution of tests. By default <b>parallel</b> is set to <em>false</em>. You can update the value to the <em>maximum number</em> of threads you want to use. Keep in mind Arrow will try to create one Browser Session <b>PER</b> parallel count. It is important that you have enough system resources to support this.
<h4><a name="How To Use?" class="anchor" href="#how-to-use"><span class="octicon octicon-link"></span></a> How To Use?</h4>

 <pre>
./node_modules/.bin/arrow &lt;some test or test descriptor&gt; --parallel=N
 or
./node_modules/.bin/arrow arrow &lt;some test or test descriptor&gt; --parallel=5
 </pre>



 <h3><a name="Using Proxy" class="anchor" href="#using-proxy"><span class="octicon octicon-link"></span></a>Using Proxy</h3>
 <h4><a name="Features of Arrow Proxy server" class="anchor" href="#features-of-arrow-proxy-server"><span class="octicon octicon-link"></span></a>Features of Arrow Proxy server</h4>

 User will need to use proxy for following reasons,

 <ul>
<li>When user wants to redirect page to specific box</li>
<li>When user wants to verify that certain calls are happening for a given URL</li>
<li>When user wants to manipulate headers, This can be helpful replacing parameter such as user-agent</li>
</ul>

 <h4><a name="Using --startProxyServer" class="anchor" href="#using--startProxyServer"><span class="octicon octicon-link"></span></a>Using --startProxyServer</h4>
<p>
 --startProxyServer param is used to start the proxy as soon as the test runs. It is defined at descriptor level.
</p>
 The descriptor will look something like this after adding this param.

 <h4><a name="simple-proxy-descriptor.json" class="anchor" href="#simple-proxy-descriptor.json"><span class="octicon octicon-link"></span></a>simple-proxy-descriptor.json</h4>
 <pre>
 [
     {
         "settings": [ "master" ],

         "name" : "descriptor",

         "startProxyServer" : true,

         "config" :{
            "baseUrl" : "http://www.yahoo.com"
         },

         "dataprovider" : {

             "dom" : {
                 "params" : {
                     "test" : "test-yahoo.js",
                     "page" : "$$config.baseUrl$$"
                 },
                 "group" : "int"

             }

         }

     },

     {
         "settings": [ "environment:development" ],
         "config": {
            "baseUrl": "http://news.yahoo.com"
         }
     },
     {
         "settings": [ "environment:production" ],
         "config": {
            "baseUrl": "http://sports.yahoo.com"
         }
     }
 ]
</pre>
 <p>
 Note: This parameter can be passed from the command line, using --startProxyServer=true depending upon your need. Always the one passed from command line will take precedence over the one which is set inside the descriptor
 </p>
 This will create a proxy.log file at the descriptor level.

 <h4><a name="Using --routerConfigProxy" class="anchor" href="#using--routerConfigProxy"><span class="octicon octicon-link"></span></a>Using --routerConfigProxy</h4>
 <p>
 --routerConfigProxy param is used to route the traffic of a page to a specific host/box. It refers to router.json file which contains the host to which you want to enroute your traffic for a given url.
 </p>
<p>
    This param is defined inside the descriptor file.
</p>


 <h4><a name="router-proxy-descriptor.json" class="anchor" href="#router-proxy-descriptor.json"><span class="octicon octicon-link"></span></a>router-proxy-descriptor.json</h4>
<pre>
 [
     {
         "settings": [ "master" ],

         "name" : "descriptor",

         "startProxyServer" : true,

         "routerProxyConfig" : "./router.json",

         "config" :{
            "baseUrl" : "http://www.autos.yahoo.com"
         },

         "dataprovider" : {

             "dom" : {
                 "params" : {
                     "test" : "test-one-yahoo.js",
                     "page" : "$$config.baseUrl$$"
                 },
                 "group" : "int"

                 }

             }

     },

     {
        "settings": [ "environment:development" ],
        "config": {
            "baseUrl": "http://news.yahoo.com"
            }
     },
     {
        "settings": [ "environment:production" ],
        "config": {
            "baseUrl": "http://sports.yahoo.com"
            }
     }
 ]
</pre>

 <h4><a name="router.json" class="anchor" href="#router.json"><span class="octicon octicon-link"></span></a>router.json</h4>

<pre>

 {
     "autos.yahoo.com" : "x.x.x.x",
     "yahoo.com" : {
        "newHost" : "y.y.y.y"
    }
 }
</pre>

For given descriptor it will route all the requests for http://www.autos.yahoo.com to the host x.x.x.x [ Replace x.x.x.x with actual host name]

 <h4><a name="Using record:true with --routerConfigProxy" class="anchor" href="#using-record:true-with--routerConfigProxy"><span class="octicon octicon-link"></span></a>Using record:true with --routerConfigProxy</h4>
 <p>
 Inside router.json file record:true param can be used in cases where user wants to confirm that certain calls are happening while loading some URLs.
 </p>
 The descriptor will look like this

 <h4><a name="proxy-record-controller-descriptor.json" class="anchor" href="#proxy-record-controller-descriptor.json"><span class="octicon octicon-link"></span></a>proxy-record-controller-descriptor.json</h4>
 <pre>
 [
     {
         "settings":[ "master" ],

         "name":"controllers",

         "startProxyServer" : true,

         "routerProxyConfig" : "./data/arrow_test/proxy_test/router.json",

         "config":{
         "baseUrl":"http://sports.yahoo.com"
     },

     "dataprovider":{

             "Test proxy Controller":{
             "group":"func",
             "controller":"./proxy-controller-record.js",
             "params":{
                    "page":"$$config.baseUrl$$",

                    "test":"./test-proxy.js"

                 }
             }
          }
     },
     {
         "settings":[ "environment:development" ]
     }
 ]
</pre>

 The only change has to happen in router.json is to include record:true,

 <h4><a name="router2.json" class="anchor" href="#router.json"><span class="octicon octicon-link"></span></a>router.json</h4>
<pre>

 {
     "finance.yahoo.com" : {
         "newHost" : "x.x.x.x",
         "record" : true
     }
 }
 </pre>
 <p>
 The recorded traffic is in JSON format and can be read from the controller using self.getProxyRecord(). The record can be reset by invoking self.resetProxyRecord().
 </p>
 <p>
 <strong>Note:</strong> The proxy record is per routerProxyConfig. If multiple tests use same routerProxyConfig and the tests are run in parallel, using resetProxyRecord() might end up resetting proxy record for other test.
 </p>
 Example -

<pre>

 var util = require("util");
 var log4js = require("yahoo-arrow").log4js;
 var Controller = require("yahoo-arrow").controller;

 function ProxyCustomController(testConfig,args,driver) {
     Controller.call(this, testConfig,args,driver);
     this.logger = log4js.getLogger("ProxyCustomController");
 }

 util.inherits(ProxyCustomController, Controller);

 ProxyCustomController.prototype.execute = function(callback) {
     var self = this;
     self.resetProxyRecord(); // Reset the proxy record

     if(this.driver.webdriver){

             var page = this.testParams.page;
             var webdriver = this.driver.webdriver;

             webdriver.get(page);

             webdriver.waitForElementPresent(webdriver.By.css(".title")).then(function() {

                 var record = self.getProxyRecord(); // Get the proxy record

                 self.testParams.proxyManagerRecord=record;
                 self.driver.executeTest(self.testConfig, self.testParams, function(error, report) {
                 callback();
             });

            });
         }else{
             this.logger.fatal("Custom Controllers are currently only supported on Selenium Browsers");
             callback("Custom Controllers are currently only supported on Selenium Browsers");
        }
     }

 module.exports = ProxyCustomController;
</pre>

 <h4><a name="Using header manipulation with --routerConfigProxy" class="anchor" href="#header-manipulation-with-proxy"><span class="octicon octicon-link"></span></a>Using header manipulation with --routerConfigProxy</h4>
Sometimes user wants to manipulate headers when calling certain urls. It can be done from router.json as shown below.

 <h4><a name="router-header.json" class="anchor" href="#router-header.json"><span class="octicon octicon-link"></span></a>router-header.json</h4>
<pre>
 {
     "sports.yahoo.com" : {
     "headers" : [
        {
            "param" : "User-Agent",
            "value" : "Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_2_1 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5"
        }
     ],
     "newHost" : "x.x.x.x",
     "record" : true
     }
 }
</pre>

 This will pass the value of param 'User-Agent' to the specified value for 'sports.yahoo.com' and runs the test for iphone user-agent.

<h3><a name="Auto scan share libraries and controllers" class="anchor" href="#share-libraries"><span class="octicon octicon-link"></span></a>Auto scan share libraries and controllers</h3>

<p> A test case might need use some share libraries. The arrow command line option: "--lib" can be used to load the share lib module, but, for complex test case, it might need load a lot of share lib modules which is installed in many places, it would be hard to maintain such a long "--lib" list.</p>
 <p>The share library auto scanner makes it simple.   </p>

 <p>Arrow provides a configuration item: config.scanShareLibPath to set scan path, or by command line option: "--shareLibPath", which will override configuration. Use comma to seperate if want to specify more than one directory to scan.
 </p>
 Once share lib path is set, when arrow is launched, it will recursively search the YUI module (.js file) under the given path (directory), and follows the subfolder name convention as below:

 <ul>
 <li>directory name starts with a prefix like "martini_"; </li>
 <li>subfolder: lib for share libraries;      </li>
 <li>subfolder: lib/server for share libraries can be loaded on server side;  </li>
 <li>subfolder: lib/client for share libraries can be loaded on client side;       </li>
 <li>subfolder: lib/common for share libraries can be loaded on both server side and client side;</li>
 <li>subfolder: controller for custom controllers;                                                    </li>
 <li>there can be subfolders under above folders, and arrow will scan them recursively.                    </li>
 </ul>
 <pre>

 martini_lib1
 |-----lib/
 |      |-----server/
 |      |       |-----module1
 |      |       |      |-----xxx.js
 |      |       |
 |      |       |-----module2
 |      |       |      |-----xxx.js
 |      |
 |      |-----client/
 |      |       |-----xxx.js
 |      |
 |      |-----common/
 |              |-----xxx.js
 |
 |-----controller/
 |      |-----my-sample-controller.js
 |
 |-----node_modules
 |-----package.json

 </pre>
 <p>
 The module under client directory will be registered as client module, the module under server directory will be registered as server module, the module under common directory will be registered as both client and server module. The controller directory is for custom controller.
 </p>

<p>
 Arrow will register the share libraries which followed above directory layout convention, as server side modules, client side modules, or custom controllers,  then we can still use common methods to load these module as other YUI Gallery modules in our test code, like YUI().use('module') or YUI.add(xxx ... require('module')), arrow would find and load the required module for it.
</p>

<p>
 For custom controller, arrow will add "package_name." as prefix, like for above sample, then to specify custom controller in test descriptor, we can use controller path, or use "martini_lib1.my-sample-controller" instead.

 <h4><a name="How To Use '--shareLibPath'" class="anchor" href="#how-to-use-sharelib"><span class="octicon octicon-link"></span></a>How To Use '--shareLibPath'</h4>
<p>
 1. Find or create a npm package which has share library and followed above convention, install it locally or globally, for example
</p>
 <pre>  npm install martini_testlib1 -g </pre>

 2. Specify the install path to ``--shareLibPath``

 <pre>  ./node_modules/.bin/arrow test-unit.js --shareLibPath=/usr/local/lib/node_modules/martini_testlib1  </pre>

 If installed more than one share lib packages globally, like martini_testlib2, we can specify multiple paths to ``--shareLibPath``, or specify the parent folder to ``--shareLibPath``.

 <pre>  ./node_modules/.bin/arrow test-unit.js --shareLibPath=/usr/local/lib/node_modules/martini_testlib1,/usr/local/lib/node_modules/martini_testlib2
  ./node_modules/.bin/arrow test-unit.js --shareLibPath=/usr/local/lib/node_modules/
</pre>
 3. Use custom controller. In test descriptor, now we can use package_name.controller_name in <strong>controller</strong> node, as below:

<pre>   "controller": "martini_testlib1.my-test-controller"
</pre>

 <strong>Note:</strong>
<p>
 1. If want to let '--shareLibPath' to scan some directory other than martini_xxx, you can configure it on <em>/path/to/arrow/install/path/config/config.js</em>, for example, to scan dev_xxx directory, you can configure it as below:
 <pre>
config.scanShareLibPrefix = ["martini_", "dev_"];
 </pre>
</p>

 2.Another config is config.scanShareLibRecursive.If set to false, arrow will only scan top level folders for the given prefix and given scan path,otherwise it will scan recursively with the given path.</p>

 3.<strong>And the next config: config.enableShareLibYUILoader ,this is important configuration.</strong> </p>
 By default false ,arrow will inject all necessary share lib source code into test cases . If true, arrow will generate and inject YUI group/modules info and let YUI loader to load modules.To ensure YUI loader to get these modules,arrow will auto detect if arrow server is running and will restart it for YUI loader if not.
 The reason we need this switch is because in yahoo network lot of time lab manager windows VM's don't have access to any non-80 port of hudson slaves.In those scenarios, YUI config would be a blocker and YUI loader wont work.So if you can make sure the pages
 you are testing have access to your host where arrow server runs, you can make enableShareLibYUILoader true to improve performance.

 <pre>
 ./node_modules/.bin/arrow test-unit.js --shareLibPath=/usr/local/lib/node_modules/ --enableShareLibYUILoader=true
 </pre>


 <h3><a name="Reporting" class="anchor" href="#reporting"><span class="octicon octicon-link"></span></a>Reporting</h3>

 Arrow supports two reporting formats, the ever-popular JUnit.xml format and Arrow's own JSON format. Reporting is particularly important if you use test descriptors to execute your tests, because each test.js file will have its own set of results. However, using Arrow's reporting feature will merge the individual results into one report.

 <h4><a name="How To Use it?" class="anchor" href="#how-to-use"><span class="octicon octicon-link"></span></a> How To Use?</h4>

 To tell Arrow you would like to create reports simply type:

<pre>./node_modules/.bin/arrow &lt;some test or test descriptor&gt; --report=true  </pre>
 <p>
 After the test executes two files will be created - <em>&lt;descriptor name&gt;-report.xml</em> and <em>&lt;descriptor name&gt;-report.json</em>.
 </p>
 <p>
 Running multiple descriptors using 'arrow "**/*-descriptor.json" --report=true' , will create &lt;descriptor name&gt;-report.xml and &lt;descriptor name&gt;-report.json for each descriptor.
 </p>
 If "reportFolder" is passed .eg . --reportFolder=/reportPath/, the reports will be generated under /reportPath/arrow-report. Under "arrow-report", Arrow creates a directory structure similar to that for descriptors. </p>
 e.g if the descriptors being run are dir1/descriptor1.json and dir2/descriptor.json, the corresponding reports will be stored under /reportPath/arrow-report/dir1/ and /reportPath/arrow-report/dir2/ respectively.</p>
 A summarized report is also created by the name "arrow-test-summary" in both xml and json formats under /reportPath/arrow-report directory. In addition, a time report is generated in json format which shows the time taken for each descriptor to complete as well as the time taken by each test within the descriptor.
 </p>
 <p>
 If "reportFolder" is not passed, the reports are generated under "arrow-target" directory e.g "arrow-target/arrow-report" wrt the location from which you executed Arrow.
 </p>
 <p>Hudson supports report globbing, so you can pass "**/*-report.xml", and it will pick up all your result files.
 </p><p>
 If --report is set to true,screenshots are created under "arrow-target/arrow-report/screenshots" directory ( if --reportFolder is not set) or under {reportFolder}/arrow-report/screenshots directory.
 </p><p>If --report is not set to true, screenshots are created under "screenshots" directory wrt the location where the tests are executed from.
 </p><p>
 By default, Arrow deletes the reports directory ( if exists) created from the previous run, before the tests are executed. If you dont want to overwrite the reports from previous run, use --keepTestReport=true.
    <strong>Note:</strong>This will only keep the reports for a descriptor from the previous run, if that descriptor is not part of current run. The summary and time reports will always be overwritten.
 </p>

 <h4><a name="report.xml sample" class="anchor" href="#report.xml-sample"><span class="octicon octicon-link"></span></a>report.xml sample</h4>
 <pre>
 &lt;testsuite failures='0' time='26.14' errors='0' skipped='0' tests='1' name='controllers'&gt;
     &lt;properties&gt;
         &lt;property name='descriptor' value='test-descriptor.json'/&gt;
     &lt;/properties&gt;
        &lt;testcase time='10' classname='Test YHOO Ticker.testCaseyui_3_2_0_18_133850857473827' name='test quote'/&gt;
 &lt;/testsuite&gt;
 </pre>

 <h4><a name="report.json sample" class="anchor" href="#report.json-sample"><span class="octicon octicon-link"></span></a>report.json sample</h4>
<pre>

 [
     {
         "passed":1,
         "failed":0,
         "total":1,
         "ignored":0,
         "duration":15,
         "type":"report",
         "name":"Quote Page test of the test",
         "testCaseyui_3_2_0_18_133850857473827":{
             "passed":1,
             "failed":0,
             "total":1,
             "ignored":0,
             "duration":10,
             "type":"testcase",
             "name":"testCaseyui_3_2_0_18_133850857473827",
             "test quote":{
                 "result":"pass",
                 "message":"Test passed",
                 "type":"test",
                 "name":"test quote",
                 "duration":1
                }
         },
         "timestamp":"Thu May 31 16:56:33 2012",
         "ua":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:12.0) Gecko/20100101 Firefox/12.0",
         "testName":"Test YHOO Ticker"
     }
 ]
</pre>

 <h4><a name="timeReport.json sample" class="anchor" href="#timeReport.json-sample"><span class="octicon octicon-link"></span></a>timeReport.json sample</h4>
<pre>

 { "descriptors":[
         {
             "descriptor":"descriptors/test-descriptor-1.json",
             "time":"9.15 seconds",
             "tests":[
                 {
                 "Testname":"Test YAHOO Search 1",
                 "Time":"5.21 seconds"
                 } ,
                 {
                     "Testname":"Test YAHOO Search 2",
                     "Time":"3.94 seconds"
                 }
             ]
         } ,
         {
             "descriptor":"descriptors/test-descriptor-2.json",
             "time":"3.55 seconds",
             "tests":[
                 {
                    "Testname":"Test YAHOO Search 3",
                    "Time":"3.55 seconds"
                 }
             ]
         } ,
         {
             "descriptor":"descriptors/test-descriptor-3.json",
             "time":"3.33 seconds",
             "tests":[
                 {
                    "Testname":"Test YAHOO Search 4",
                    "Time":"3.33 seconds"
                 }
             ]
         }
 ], "Total time":"17.09 seconds"  }

 </pre>


 <h3><a name="Code Coverage" class="anchor" href="#code-coverage"><span class="octicon octicon-link"></span></a>Code Coverage</h3>

 <h4><a name="Node side code coverage" class="anchor" href="#node-code-coverage"><span class="octicon octicon-link"></span></a>Node side code coverage</h4>

 To tell Arrow you would like to create code coverage report simply type:

<pre> arrow &lt;some test or test descriptor&gt; --coverage=true
</pre>
By default all js files are (and it's require files) parsed from cmd line : --lib or test descriptor: commonLib/lib will get instrumented and generate code coverage report after all tests done.
<p>And two more optional params to use for coverage:
<pre>
 --coverageExclude : (optional) string. comma-separated list of files to exclude from coverage reports"
 --keepIstanbulCoverageJson : (optional) true/false. if set to true, it does not delete Istanbul coverage json files. (default: false)
</pre>

 <h4><a name="Client side code coverage" class="anchor" href="#client-code-coverage"><span class="octicon octicon-link"></span></a>Client side code coverage</h4>
<p>
 If you want to collect client(browser) side code coverage(thus,some libs served on the test page),then you will use arrow proxy server.
</p> In your test descriptor you can config like :

<pre>

 {
     "settings": [ "master" ],
     "name": "client side test",
     "config": {
     },

     "startProxyServer": true,
     "routerProxyConfig": "./proxy_config.json",

     "dataprovider": {

         "iframe_client": {
             "group": "client",
             "params": {
                 "test": "test-client.js",
                 "page": "url/to/the/test/page"
             }
         }
     }
 }
</pre>

 Make sure you have set "startProxyServer" to true and add a config for proxy - proxy_config.json:

<pre>
 {
     "router": {
         "news.yahoo.com": {
         "newHost": "x.x.x.x (your new host ip/name)",
         "headers": [
             {
                "param": "&lt;param&gt;",
                "value": "&lt;val&gt;"
             }
         ],
         "record": true
         }
     },
     "coverage": {
         "clientSideCoverage": true,
         "coverageExclude": ["^http://yui.yahooapis.com.*\\.js$"],
         "timeout": 5000
     }
 }
 </pre>

 <p>In this proxy_config ,the "router" defines router table where you can modify the test page with new host and new headers for all calls being made by browser.Also supports recording of select url calls if set "record" to true.
 </p>In coverage field you can set "clientSideCoverage" to true and add a filter to ignore some js files in "coverageExclude".And if your page has multiple cross-domain frames and you can enlarge the timeout seconds waiting for coverage data
 collecting.
 <p>
 Then in arrow cmd you can type:

<pre>arrow test_descriptor.json --browser=chrome --logLevel=debug --coverage=true</pre>

 You can see that all js file except those defined in "coverageExclude" will get instrumented and generate code coverage.

 <h4><a name="Client side code coverage Notes" class="anchor" href="#client-code-coverage-notes"><span class="octicon octicon-link"></span></a>Client side code coverage Notes</h4>

 1. If you have multiple test(session) and multiple page run in one descriptor, then all libs coverage data in these pages(even if the lib are
 loaded from different page but with same source url , like yui-min file) will be merged and generate one report.

 <pre>

 "news": {
     "group": "client",
     "params": {
         "test": "testnews.js",
         "page": "http://news.yahoo.com"
     }
 },
 "finance": {
     "group": "client",
     "params": {
         "test": "testfinance.js",
         "page": "http://finance.yahoo.com"
     }
 }
 </pre>
 2. If you have one test (session) but with multiple pages, for example,you first launch yahoo news page then go to finance page, then only the libs on finance page will
 get collected (because when switch to to another page,the previous page coverage data was lost).

<pre>

 "multiple-page" : {
     "params" :{
         "scenario": [
             {
                "page": "http://news.yahoo.com"
             },
             {
                 "controller": "locator",
                 "params": {
                     "value": "#mediasearchform-submit",
                     "click": true
                 }
             },
             {
                "page": "http://finance.yahoo.com"
             },
             {
                 "test": "test-title.js",
                 "title": "Yahoo! Finance - Business Finance, Stock Market, Quotes, News"
             }
         ]
     }
 }
</pre>
 3.For some pages like yahoo login page, we can't proxy it in arrow proxy server due to some strict restriction policy. But you can add router to route to another mocked login page or
 just add a filter to  "coverageExclude" in page level:

<pre>

 "coverage": {
     "clientSideCoverage": true,
     "coverageExclude": ["^http://login.yahoo.com$"]
 }
</pre>
 Then login page won't be instrumented and collect coverage. <p></p>

 4.Https pages are not supported yet.

 <h3><a name="More YUI Asserts" class="anchor" href="#more-YUI-asserts"><span class="octicon octicon-link"></span></a>More YUI Asserts</h3>

 <h4><a name="Extended version of Assertions" class="anchor" href="#extended-version-of-assertions"><span class="octicon octicon-link"></span></a>Extended version of Assertions</h4>

 <pre>
 Y.Assert.isUrl - Is a valid URL
 Y.Assert.isMatch - Match string against supplied Regex
 Y.Assert.hasKey - Does Object have a specific key
 Y.Assert.hasValue - Does Object have a specific value
 Y.Assert.hasDeepKey - Validate key exists in a nested object
 Y.Assert.hasDeepValue - Validate value exists in a nested object
 Y.Assert.operator - Compare two values
 Y.Assert.isNode - Validate a Dom Node exists
 Y.Assert.nodeTextEquals - Validate text of a Dom node equals expected value
 Y.Assert.nodeTextExists - Validate Dom node has text in it
 Y.Assert.nodeCount - Validate selector counts(look at example below)
 Y.Assert.nodeContains - Validate if given needle is within the HTML of a module
 Y.Assert.isImage - Validate if Dom node is a valid image
 Y.Assert.isAnchor - Validate if Dom node is a valid anchor
</pre>

 <h4><a name="How to use the above assertions?" class="anchor" href="#how-to-use-assertions"><span class="octicon octicon-link"></span></a>How to use the above assertions?</h4>
<p>Create a test which includes libraries 'html-module-lib' and 'dom-lib'
</p>
 Use test-assert-1.js as a test case where user checks for Y.Assert.isNode and Y.Assert.nodeCount

<pre>

 YUI.add("MyAwesomeModule-tests", function (Y) {
 'use strict';

     var suite = new Y.Test.Suite("Assertion Tests 1");

     suite.add(new Y.Test.Module({

         "name" : "Assertion Test 1",
         "id": "yuhead-com-links",

         "asserts" : {
             "Logo Present" : {
             "locator" : ".yuhead-com-link-item",
             "type" : "isNode"
            },
            "Test Greater than" : {
             "locator" : ".yuhead-com-link-item",
             "type" : "nodeCount",
             "expected" : ">1",
             "message" : "There should be more than 1 list items with class yuhead-com-link-item"
            },
            "Test Less than" : {
             "locator" : ".yuhead-com-link-item",
             "type" : "nodeCount",
             "expected" : "<5",
             "message" : "There should be more than 5 list items with class yuhead-com-link-item"
            },
             "Test Equals" : {
             "locator" : ".yuhead-com-link-item",
             "type" : "nodeCount",
             "expected" : "=3",
             "message" : "There should be 3 list items with class yuhead-com-link-item"
            }

         }
     }));

    Y.Test.Runner.add(suite);

 }, "0.1", {requires : ["test", "node", "html-module-lib", "dom-lib"]});
</pre>

 Use test-descriptor-1.json as a descriptor to run above test

<pre>
 [
     {
         "settings": [ "master" ],

         "name" : "tabview",

         "config" :{
            "baseUrl" : "http://finance.yahoo.com"
         },

        "dataprovider" : {

            "dom_int" : {
                "params" : {
                            "test" : "test-assert-1.js",
                            "page" : "$$config.baseUrl$$"
                            },
                "group" : "smoke"
            }

        }

     },

     {
     "settings": [ "environment:development" ]
     }

 ]
</pre>
 Run the test in usual way using,

 <pre>
 arrow test-descriptor-1.json --browser=chrome
 </pre>
 <p>
 Make sure it passes
 </p>
 Note: More such examples are provided in test-assert-2.js and test-descriptor-2.json


</section>
</div>

<script type="text/javascript" src="javascripts/footer.js"> </script>

</body>
</html>
